1.原始的js对象obj

2.经过reactive(obj)时，内部通过proxy劫持，添加get和set自动调用方法

3.经过effect(fn)时，fn的内容在get时track()收集起来作为后续代码执行的依赖

4.响应式对象修改属性值时，set中trigger()找到收集起来的对应依赖进行触发后再进行当前操作

5.调用effect会返回runner，它实际上就是effect传入的fn

6.effect(fn,{scheduler})时，首次调用fn，当响应式数据改变时会调用scheduler函数而不是fn

7.stop(runner)后，响应式对象的属性值修改时不会自动更改，本质是把存在ReactiveEffect依赖对象deps里的依赖删除了

7.effect(fn,{onStop})时,会在触发stop时候自动调用onStop函数，本质就是在stop时调用了一次回调

8.readonly(obj)后该obj属性值只能get不能set

9.isReactive(obj)后返回该obj是否为响应式对象，原理是再调用该target的属性时会自动触发get

10.优化stop()